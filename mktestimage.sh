#!/bin/sh

# mktestimage.sh - build a test image
#
# Take a list of ROM files and build a multi-ROM image using menu-romlisttest.gb
# as a menu and adding each ROM in arg order, with padding when necessary (a ROM
# will be aligned to an address that is a multiple of its size).
#
# menu-romlisttest.gb is built with a copy of the list of ROM entries (title+
# bank number) that will be compared at startup with the list generated by the
# menu software. This list is formed with the titles (16 chars) taken directly
# from ROM headers and cleaned as follows: chars not in the Nintendo charset are
# replaced by a space.
#
# A ROM that should not be recognized by the menu (maybe because the header is
# corrupted) must have a title beginning with "**IGN**".
#
# A list of ROMs sorted by title is also joined to test the sort routine. This
# list is only composed of bank numbers.
#
# if the -d option is provided, a listing of the ROMs and free space will be
# dumped.
#
# The -f option may be used to pad the image to make its size 4096 KB (a full
# page). This is useful when using ems-flasher as this program doesn't erase
# ROMs located after the newly written image.

set -eu

trap 'rm -f "$romlistf" testromlist.inc' EXIT

# Output $1 0xff chars
# For padding. 
pad()
{
    yes $(printf '\377') | tr -d '\n' | head -c"$1"
}

romlistf=$(mktemp)

usage() {
    cat >&2 <<EOT
usage: $(basename "$0") [-df] -o IMAGEFILE [ROMFILE...]

Options:
 -d           output an image map for debugging
 -f           pad the image to make its size 4096 KB (a full page)
 -o IMAGEFILE target image
EOT
    exit 1
}

debug=0 fill=0 imagef=
while getopts 'dfo:' opt; do
    case $opt in
    d) debug=1;;
    f) fill=1;;
    o) imagef=$OPTARG;;
    *) usage
    esac
done

[ -n "$imagef" ] || usage

shift $((OPTIND-1))

# Reserve the first 32KB for the menu
if ! dd if=/dev/zero of="$imagef" count=32 bs=1024 2>/dev/null; then
    echo "dd failed" >&2
    exit 1
fi

# Add the ROMs

ofs=32768
for romf; do
    # Retrieve the 16 chars of the ROM title from the header and replace
    # characters outside the Nintendo character (32-95) set by a space
    title_clean=$(dd if="$romf" skip=308 bs=1 count=16 2>/dev/null \
                      | tr -c '\40-\137' ' ')
    size=$(wc -c < "$romf")

    if [ "$size" -eq 0 ] || [ $((size & (size-1))) -ne 0 ]; then
        echo "error: the size of $romf is not a power of two" >&2
        exit 1
    fi

    # Compute the padding (a ROM must be aligned to an address that is a
    # multiple of its size)
    if [ $((ofs%size)) -ne 0 ]; then
        pad=$((size - ofs%size))
        pad $pad >> "$imagef"
        if [ $debug -ne 0 ]; then
            printf "%d\t%-16s\t%d\n" $((ofs>>10)) "**FREE**" $((pad>>10))
        fi
    else
        pad=0
    fi

    cat "$romf" >> "$imagef"

    ofs=$((ofs+pad))

    if [ $debug -ne 0 ]; then
        printf "%d\t%s\t%d\t%s\n" $((ofs>>10)) "$title_clean" $((size>>10)) $romf
    fi

    if [ $(expr "$title_clean" ':' '\*\*IGN\*\*' ) -eq 0 ]; then
        printf "%d\t%s\n" $((ofs/16384)) "$title_clean" >>"$romlistf"
    fi

    ofs=$((ofs+size))

    if [ $ofs -gt $((4096<<10)) ]; then
        echo "error: not enough space in image file" >&2
        exit 1
    fi
done

if [ $fill -ne 0 ]; then
	pad $(((4096<<10)-ofs)) >> "$imagef"
fi

if [ $debug -ne 0 ]; then
    printf "$((ofs>>10))\t**END**\n"
fi

# Build testromlist.inc, the list of ROM entries (bank+title) and the sorted
# list that will be compiled with the menu software.
# Assembler used is RGBDS.

(
echo "uromlisttest_start:"
# Ouput an entry as <TAB>db <bank number>, "<title>".
# Each title has a fixed size of 16 chars and backslashes, double quotes, curly
# brackets are escaped. We are using RGBDS.
sed -e 's/\\/\\\\/g; s/"/\\"/g; s/{/\\{/g; s/}/\\}/g;' \
    -e 's/\(.*\)\t\(.*\)/\tdb \1, "\2"/' \
    "$romlistf"
echo "uromlisttest_end:
uromlisttest_nb equ (uromlisttest_end-uromlisttest_start)/17
"

# Output the bank numbers of the ROM entries sorted by title in ASCII ascending
# order.

echo "sromlisttest_start:"
LC_ALL=C sort -t"$(printf '\t')" -k2,2 "$romlistf" | awk '{print "\tdb "$1}'
echo "sromlisttest_end:
sromlisttest_nb equ sromlisttest_end-sromlisttest_start"
) >testromlist.inc

# Compile and write the menu to the start of the image.
make -s menu-romlisttest.gb
if ! dd if=menu-romlisttest.gb of="$imagef" conv=notrunc 2>/dev/null; then
    echo "dd failed" >&2
    exit 1
fi
